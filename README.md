# LabN3
## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2402`

#### Выполнил: `Соколовская Снежана Владимировна`

#### Вариант: `22`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Классы](#2-классы)
- [Описание](#3-описание)

### 1. Постановка задачи

- Условия задачи
 > Передо мной стояла задача разработать программу для работы с графами, представленными в виде набора рёбер, а также реализовать функции для анализа структуры графа, добавления и удаления рёбер и вершин, определения свойств графа и выполнения операций над ним.

### 2. Классы

1. Класс `Graph`:
Класс Graph представляет граф с вершинами и рёбрами. Он отвечает за хранение данных о графе и выполнение различных операций с графом. В нем хранится массив ребер, вершин.
2. Класс `Main`:
Этот класс используется для тестирования функциональности класса Graph и демонстрации работы всех его методов.


### 3. Описание

В этот раз мы учтем тестовый класс `Main`.



**1. Класс `Graph`:**

Сначала я создаю поля класса Graph, которые отвечают за хранение структуры графа и управление его элементами. Двумерный массив edges хранит рёбра графа. Счётчик рёбер, который показывает, сколько рёбер добавлено в массив edges на данный момент.
Используется для добавления новых рёбер и контроля заполненности массива.
Одномерный массив vertices хранит вершины графа.
Каждая вершина представляется числом (например, её уникальный идентификатор или метка). private означает, что этот массив доступен только внутри класса Graph. Счётчик вершин, который показывает, сколько вершин добавлено в массив vertices на данный момент. Он позволяет отслеживать, сколько вершин реально используется.

Далее я создаю конструктор класса Graph, который создает граф с фиксированным максимальным количеством рёбер и вершин, используя массивы. Он принимает два параметра:
maxEdges — максимальное количество рёбер.
maxVertices — максимальное количество вершин.
Создаётся двумерный массив edges, который хранит рёбра графа. Количество строк в массиве — maxEdges (т.е. максимальное количество рёбер).
Количество столбцов — 2, так как каждое ребро соединяет две вершины.
Далее я создаю одномерный массив vertices, который хранит вершины графа.
Количество элементов — maxVertices, т.е. максимальное число вершин.
edgeCount — счётчик количества рёбер, изначально 0.
vertexCount — счётчик количества вершин, изначально 0.

1. метод edgeExists

Приватный метод, доступный только внутри класса Graph.
Принимает два параметра v1 и v2 — индексы (или идентификаторы) двух вершин.
Возвращает true, если ребро (v1, v2) уже есть в графе, иначе false.
Сначала я прохожусь по всем рёбрам, добавленным в массив edges (до edgeCount).
edgeCount указывает, сколько рёбер реально используется, поэтому проверяем только заполненные элементы массива. Проверяем, совпадает ли начальная вершина edges[i][0] с v1 и конечная вершина edges[i][1] с v2.
Если да — значит, такое ребро уже существует, и возвращаем true. Если после перебора всех рёбер не нашли нужное, возвращаем false, означающее, что такого ребра в графе нет.

3. метод vertexExists

Приватный метод, доступный только внутри класса Graph.
Принимает один параметр v — номер (идентификатор) вершины.
Возвращает true, если вершина v уже есть в графе, иначе false.
Сначала перебираем все добавленные вершины, количество которых хранится в vertexCount.
vertexCount указывает, сколько вершин реально занято в массиве vertices.
Проверяем, есть ли в массиве vertices элемент, равный v.
Если найдено совпадение, значит вершина уже есть, и сразу возвращаем true. Если после перебора всех элементов вершина v не найдена, возвращаем false.

4. метод addVertex

Также приватный метод.
Принимает один параметр v — номер (идентификатор) вершины.
Не возвращает значение (void), так как просто добавляет вершину.
для начала я вызываю метод vertexExists(v), чтобы проверить, есть ли уже такая вершина в массиве vertices.
Если vertexExists(v) == true, значит вершина уже есть, и добавление не выполняется.
Если vertexExists(v) == false, продолжаем добавление.
Затем сравниваем vertexCount и vertices.length:

  vertexCount — текущее количество добавленных вершин.
  vertices.length — максимальная вместимость массива.
  
Если ещё есть свободное место, продолжаем добавление.
Записываем новую вершину в массив vertices по индексу vertexCount.
Увеличиваем vertexCount, так как добавили новую вершину.
Если места в массиве нет (vertexCount >= vertices.length), выводим сообщение о переполнении.

4. метод printEdges

Публичный метод, доступный из других классов.
Не принимает параметров и ничего не возвращает (void), так как просто выводит информацию.
Цикл перебирает все добавленные рёбра (i < edgeCount).
edgeCount показывает, сколько рёбер реально добавлено в массив edges, поэтому цикл не проходит по пустым ячейкам.
Выводит каждое ребро в виде:

1 -> 2

3 -> 4

edges[i][0] — начальная вершина ребра.
edges[i][1] — конечная вершина ребра.

5. метод printVerticesDescending

Также публичный метод. Сначала я создаю новый массив sortedVertices, который будет содержать копию массива vertices, но отсортированную.
Копируем в него только реально добавленные вершины (до vertexCount). Используется пузырьковая сортировка для упорядочивания вершин по убыванию.
Внутренний цикл сравнивает соседние элементы и меняет их местами, если текущий элемент меньше следующего.
В итоге самые большие значения "всплывают" в начало массива. Перебирает массив sortedVertices и выводит вершины через пробел.

6. метод printVerticesWithIncomingEdgesMoreThan

Принимает один параметр count — минимальное количество входящих рёбер. Сначала я прохожусь циклом по всем вершинам в массиве vertices (до vertexCount).
v — текущая вершина, для которой будем считать количество входящих рёбер.
incoming — счётчик входящих рёбер, изначально 0.
Перебираем все рёбра в массиве edges (до edgeCount).
Если edges[j][1] == v, значит v является конечной вершиной (v — получатель рёбра).
В таком случае увеличиваем счётчик incoming.
Если количество входящих рёбер incoming больше count, выводим вершину v. Добавляем новую строку в конце, чтобы следующий вывод был корректным.

7. метод removeEdge

Метод принимает два параметра:
v1 — начальная вершина ребра.
v2 — конечная вершина ребра.
Если нет рёбер (edgeCount == 0), то сразу выводим сообщение и прекращаем выполнение (return). Затем перебираем все рёбра в массиве edges (до edgeCount).
Если найдено ребро, где edges[i][0] == v1 и edges[i][1] == v2, значит, это ребро существует.
Удаление реализую через замену:
Последний элемент массива edges[edgeCount - 1] копируется на место удаляемого edges[i].
Затем уменьшаем edgeCount, чтобы "забыть" последний элемент.
Такой метод позволяет избежать сдвига всех элементов, ускоряя удаление.
Выводится сообщение "Ребро v1 -> v2 удалено.", затем return завершает выполнение метода.
Если цикл прошёл все рёбра и не нашёл совпадение, выводится сообщение "Ребро v1 -> v2 не найдено.".

8. метод removeVertex

Принимает один параметр v — вершину, которую нужно удалить. Перебираем все рёбра в массиве edges (до edgeCount).
Если ребро не содержит v (не исходит из неё и не ведёт в неё), оставляем его в массиве.
Сдвигаем оставшиеся рёбра в начало массива, используя индекс index.
После завершения цикла обновляем edgeCount, чтобы исключить "стертые" рёбра.
Перебираем массив vertices, ищем вершину v.
Если текущая вершина не равна v, переносим её в начало массива.
Обновляем vertexCount, чтобы исключить удалённую вершину. И сообщаем пользователю, что вершина и все её рёбра успешно удалены.

9. метод removeVerticesWithFewestIncomingEdges

Если граф пуст (нет вершин), просто выходим из метода. Создаём массив incomingEdges размером vertexCount, где incomingEdges[i] будет хранить количество входящих рёбер для вершины vertices[i].
Изначально массив заполнен нулями. Перебираем все рёбра в массиве edges.
Если edges[i][0] == edges[i][1], то это петля (ребро, соединяющее вершину с самой собой), мы её игнорируем.
Для каждого ребра (edges[i][0] -> edges[i][1]) ищем индекс получателя (edges[i][1]) в массиве vertices.
Если нашли, увеличиваем счётчик входящих рёбер для этой вершины.
Используем break, чтобы остановить внутренний цикл после первого совпадения (ускоряет работу).
Затем, чтобы найти минимальное кол-во входящих ребер, устанавливаем начальное минимальное значение minIncoming = incomingEdges[0].
Проходим по всем вершинам и находим минимальное количество входящих рёбер. Проходим по вершинам и ищем те, у которых incomingEdges[i] == minIncoming.
Вызываем removeVertex(vertices[i]), чтобы удалить вершину.
После удаления сдвиг вершин меняет индексы, поэтому i--, чтобы не пропустить следующую вершину.

10. метод countConnectedComponents (содержит два приватных метода)
    
Сначала я создаю массив для отслеживания посещённых вершин. count — счётчик компонент связности.
Перебираем все вершины.
Если вершина ещё не посещена, запускаем DFS (dfs(i, visited)) и увеличиваем count.
Каждое новое вызванное DFS означает новую компоненту связности.

Разбор метода dfs()

Он рекурсивно обходит все вершины, связанные с vertices[vIndex]. Запоминаем, что вершина vertices[vIndex] посещена. Проходим по всем рёбрам. Обходим соседние вершины: 
Ели текущее ребро edges[i] исходит из текущей вершины vertices[vIndex], то:
  Находим индекс конечной вершины (edges[i][1]).
  Если она ещё не посещена, запускаем DFS для неё.
Если текущее ребро edges[i] ведёт в текущую вершину, проверяем начальную вершину edges[i][0].
Если она не посещена, запускаем dfs().

 Разбор метода getVertexIndex()

Находит индекс вершины v в массиве vertices.
Перебираем все вершины: ищем v в массиве vertices. Если нашли, возвращаем индекс. Если вершины v нет в массиве, возвращаем -1.

11. метод findConnectedComponents

Возвращает массив компонентов связности в виде массива массивов int[][], где каждая подмассив — отдельная компонента. Создаём вспомогательные структуры:
visited[i] хранит, была ли вершина vertices[i] посещена.
componentCount содержит общее количество компонент (вызывается countConnectedComponents()).
result — массив для хранения всех компонент.
componentIndex отслеживает, в какой ячейке result записывать найденную компоненту.
Перебираем все вершины.
Если вершина ещё не посещена, начинаем поиск всей компоненты, содержащей её.
Создаём массив component размером vertexCount (максимально возможный размер компоненты).
Переменная size отслеживает сколько вершин в компоненте.
Запускаем dfsCollect(), который заполняет массив component и возвращает его реальный размер.
В component есть излишние элементы (он создавался с запасом).
Создаём finalComponent — точно нужного размера и копируем туда вершины.
Добавляем finalComponent в result.
Увеличиваем componentIndex, чтобы следующая компонента записалась в новый слот.
Выводим найденную компоненту в формате { 1 2 3 }.

Разбор метода dfsCollect()

Приватный метод, выполняющий DFS и собирающий вершины одной компоненты.
Возвращает размер найденной компоненты. 
Вершина vertices[vIndex] помечается как посещённая.
Добавляется в массив component, увеличиваем size. Проходим по всем рёбрам. Определяем соседнюю вершину:
Если vertices[vIndex] — начальная вершина ребра edges[i], берём edges[i][1].
Если vertices[vIndex] — конечная, берём edges[i][0].
Если соседняя вершина не посещена, рекурсивно вызываем dfsCollect().
Возвращаем общее количество вершин в текущей компоненте.

12. метод printVerticesReachableInTwoSteps

Создаём вспомогательные структуры:
reachable[] — массив, куда будем записывать вершины, достижимые за два шага.
visited[] — массив, отмечающий, какие вершины мы уже посетили.
count — количество найденных достижимых вершин.
Проходим по всем рёбрам.
Если startVertex совпадает с началом ребра edges[i][0], то edges[i][1] — его сосед.
Если startVertex совпадает с концом ребра edges[i][1], то edges[i][0] — его сосед.
Добавляем найденные соседи в reachable[].
Отмечаем их как посещённые в visited[].
Увеличиваем count, так как добавили вершину.
Теперь в reachable[] хранятся все вершины, достижимые за 1 шаг.
Находим вершины, достижимые за 2 шага:
currentCount фиксирует число вершин, найденных на первом шаге.
Перебираем только эти вершины (reachable[0] ... reachable[currentCount - 1]).
vertex — текущая вершина первого шага, для которой ищем соседей.
Перебираем все рёбра, чтобы найти соседей вершины первого шага.
Если vertex совпадает с edges[j][0], значит edges[j][1] — новая достижимая вершина.
Если vertex совпадает с edges[j][1], значит edges[j][0] — новая достижимая вершина.
Проверяем, не посещали ли мы её ранее (visited[]).
Добавляем новую вершину в reachable[].
Отмечаем её посещённой.
Теперь reachable[] содержит вершины, достижимые за 1 и 2 шага.
Выводим все найденные вершины, достижимые за два хода.

13. метод printVerticesReachableInSteps

Принимает два параметра:
startVertex — стартовая вершина.
maxSteps — максимальное количество шагов (рёбер), за которое можно достичь другие вершины.
Создаём вспомогательные структуры:
visited[] — массив флагов, помечающий уже посещённые вершины.
reachable[] — массив для хранения всех достижимых вершин.
count — счётчик количества найденных достижимых вершин.
getVertexIndex(startVertex) получает индекс вершины в массиве вершин.
Помечаем её как уже посещённую, чтобы не обрабатывать повторно.
currentLevel[] — список вершин, найденных на текущем шаге.
nextLevel[] — список вершин, которые найдём на следующем шаге.
currentCount — количество вершин на текущем шаге.
nextCount — количество вершин, найденных на следующем шаге.
Ищем соседей стартовой вершины (вершины, достижимые за 1 шаг):
Проходим по всем рёбрам.
Если startVertex совпадает с edges[i][0], то edges[i][1] — его сосед.
Если startVertex совпадает с edges[i][1], то edges[i][0] — его сосед.
Добавляем соседние вершины в currentLevel[] (они будут обработаны на следующем шаге).
Помечаем их посещёнными (visited[]), чтобы избежать дубликатов.
Добавляем их в reachable[], так как они достижимы.
Теперь currentLevel[] содержит все вершины, достижимые за 1 шаг.
Поиск вершин, достижимых за maxSteps шагов:
Цикл step от 1 до maxSteps - 1.
Перебираем все вершины, найденные на предыдущем шаге (currentLevel[]).
vertex — текущая вершина, найденная на предыдущем шаге.
Ищем соседей текущих вершин:
Для каждой вершины из currentLevel[] проверяем её рёбра.
Находим её соседей, которые ещё не были посещены.
Добавляем их в nextLevel[] для обработки на следующем шаге.
Помечаем как посещённые.
Добавляем их в reachable[], так как они достижимы за ≤ maxSteps шагов.
Теперь nextLevel[] содержит вершины, достижимые на следующем шаге.
Переход к следующему уровню: 
Меняем местами currentLevel и nextLevel.
Теперь currentLevel[] содержит новые найденные вершины, а nextLevel[] очищается для следующего шага.
Выводим все вершины, достижимые за maxSteps ходов.

14. метод mergeGraph

Принимает в аргументе другой граф (other).
Добавляет в текущий граф (this) все вершины и рёбра из other.
Перебираем все вершины из второго графа other.
Проверяем, есть ли вершина в первом графе (this), используя метод containsVertex().
Если вершины ещё нет, то:
Добавляем её в массив vertices[].
Увеличиваем vertexCount (количество вершин в this). Вершины не дублируются.
Добавляем рёбра из other
Перебираем все рёбра из второго графа other.
Проверяем, есть ли такое ребро в this, используя containsEdge().
Если ребра ещё нет, то:
Добавляем его в массив edges[][].
Увеличиваем edgeCount (количество рёбер в this). Рёбра не дублируются.

Вспомогательные методы:

Метод containsVertex()

Проверяет, есть ли вершина vertex в this.
Возвращает true, если вершина найдена.
Возвращает false, если вершины нет.
Использую в mergeGraph(), чтобы избежать дубликатов вершин.

Метод containsEdge()

Проверяет, есть ли ребро (v1, v2) в this.
Возвращает true, если ребро найдено.
Возвращает false, если ребра нет.
Использую в mergeGraph(), чтобы избежать дубликатов рёбер.

15. метод isCompleteGraph

Если в графе меньше двух вершин (vertexCount < 2), то:
Граф считается полным, потому что:
Граф из 0 вершин не имеет рёбер → он тривиально полный.
Граф из 1 вершины тоже полный → у него нет несоединённых пар вершин.
Выводится: Граф полный? true (0 или 1 вершина).
Метод возвращает true.

Вычисление максимального количества рёбер
Полный граф — это граф, где каждая вершина соединена с каждой другой.
Формула для максимального количества рёбер в графе: maxEdges = (V×(V−1)) / 2
У каждой вершины есть (V - 1) возможных соседей.
Считаем рёбра дважды (из A → B и B → A), поэтому делим на 2.
Сравниваем текущее число рёбер (edgeCount) с maxEdges.
Если они совпадают (edgeCount == maxEdges), значит:
Граф полный → isComplete = true.
Если нет, значит:
В графе не хватает рёбер, и он не полный → isComplete = false. Возвращает true, если граф полный, иначе false.

16. метод isEmptyGraph
​
Граф считается пустым, если:
vertexCount == 0 → в графе нет вершин.
edgeCount == 0 → в графе нет рёбер.
Если любое из этих условий выполняется, переменная isEmpty становится true.
Если граф пустой (isEmpty == true) → возвращает true.
Если в графе есть и вершины, и рёбра → возвращает false

17. метод hasOnlySelfLoops

Перебираем все рёбра в графе (edgeCount – общее количество рёбер).
edges[i][0] — первая вершина текущего ребра.
edges[i][1] — вторая вершина текущего ребра.
Петля — это когда обе вершины ребра совпадают.
Например, (3,3), (5,5), (1,1) — это петли.
Если найдено хотя бы одно такое ребро, значит, граф содержит петлю.
Если найдено хотя бы одно ребро (x, x), программа выводит сообщение и немедленно возвращает true.
Дополнительные проверки не выполняются, так как петля уже найдена.
Если после перебора всех рёбер не найдено ни одной петли, программа выводит сообщение и возвращает false.




**4. Класс `Main`**

Как я уже упоминала, используется как тестовый. 
Создадим в нем граф и объект для отображения графа. 
Добавим данные с помощью метода addEdge();

![image](https://github.com/user-attachments/assets/2af917c6-ef28-42df-8d9d-409a85b35675)



1. graph.printEdges(); - выводим список ребер в графе

 **Output**:
 ```
Список рёбер:
1 -> 2
2 -> 4
1 -> 3
2 -> 5
3 -> 6
3 -> 7
4 -> 8
5 -> 8
6 -> 9
7 -> 9
8 -> 10
9 -> 10

```

2.  graph.printVerticesDescending(); - выводим все вершины графа по убыванию

**Output**:

```
Вершины по убыванию:
10 9 8 7 6 5 4 3 2 1 
```

3.  graph.printVerticesWithIncomingEdgesMoreThan(1); - выводим вершины с входящими рёбрами больше заданного числа

**Output**:
```
Вершины с входящими рёбрами больше 1:
8 9 10 
```

4.  graph.removeEdge(1, 5); - удаление ребра
graph.printEdges(); - проверяем удаление

**Output**:

```
Ребро 1 -> 5 не найдено.
Список рёбер:
1 -> 2
2 -> 4
1 -> 3
2 -> 5
3 -> 6
3 -> 7
4 -> 8
5 -> 8
6 -> 9
7 -> 9
8 -> 10
9 -> 10
```
5.  graph.removeVertex(5); - удаление вершины
graph.printEdges();  - проверяем

**Output**:

```
Вершина 5 и её рёбра удалены.
Список рёбер:
1 -> 2
2 -> 4
1 -> 3
3 -> 6
3 -> 7
4 -> 8
6 -> 9
7 -> 9
8 -> 10
9 -> 10
```

6. graph.removeVerticesWithFewestIncomingEdges(); - удаление вершин с наименьшим числом входящих рёбер
graph.printEdges(); - проверка
Вершина 1 и её рёбра удалены.
Вершина 2 и её рёбра удалены.
Вершина 4 и её рёбра удалены.
Вершина 3 и её рёбра удалены.
Вершина 6 и её рёбра удалены.
Вершина 7 и её рёбра удалены.
Вершина 8 и её рёбра удалены.
Вершина 9 и её рёбра удалены.
Вершина 10 и её рёбра удалены.
Список рёбер:


Далее создаем новый граф, т.к. после последнего действия в текущем были удалены все ребра. Снова выводим список ребер.

**Output**:

```
Создан новый граф
Список рёбер:
1 -> 2
2 -> 4
1 -> 3
2 -> 5
3 -> 6
3 -> 7
4 -> 8
5 -> 8
6 -> 9
7 -> 9
8 -> 10
9 -> 10

```
7.  graph1.countConnectedComponents(); - подсчёт компонент связности

**Output**:

```
Количество компонент связности: 1
```

8. graph1.findConnectedComponents(); - поиск компонент связности

**Output**:

```
Компоненты связности:
{ 1 2 4 8 5 10 9 6 3 7 }

```
9. graph1.printVerticesReachableInTwoSteps(2); - вывод вершин, достижимых за 2 шага из указанной вершины ( в данном случае из 2)

**Output**:
  
```
Вершины, достижимые из 2 за 2 хода: 1 4 5 2 3 8 
```  
10. graph1.printVerticesReachableInSteps(1, 4); - вывод вершин, достижимых за не более чем n шага из указанной вершины (здесь кол-во шагов - 4, вершина 1)

**Output**:

```
Вершины, достижимые из 1 за не более чем 4 ходов: 2 3 4 5 6 7 8 9 10 
```  

Затем создаем второй граф для объединения его с первым и получаем новый граф: 
11. graph1.mergeGraph(graph2);
        graph1.printEdges();

**Output**:
 
```
Список рёбер:
1 -> 2
2 -> 4
1 -> 3
2 -> 5
3 -> 6
3 -> 7
4 -> 8
5 -> 8
6 -> 9
7 -> 9
8 -> 10
9 -> 10
4 -> 3
6 -> 5
5 -> 6

```

12. graph1.isCompleteGraph(); - проверка графа на полноту

 **Output**:

```
Граф полный? false
```
13. graph1.isEmptyGraph(); - проверка графа на пустоту

 **Output**:
 
```
Граф пустой? false
```

14. graph1.hasSelfLoop(); - проверка на наличие петель

 **Output**:
 
```
В графе нет петель
```    



